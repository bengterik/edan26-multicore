Lab 3
Frågor:
- realloc, segmentation fault
- dubbla relabels


- Varje tråd har en lista med noder 
1. huvud-tråden:
    - delar ut alla med excess till listor
    - blockera på fas 1 barrier 

2: alla trådar
    - trådarna går igenom sin lista och registrerar vilka pushes alternativt relables som ska göras
    - blockera på fas 1 barrier
    - blockera på fas 2 barrier

3: huvud-tråden
    - utför operationerna i varje tråds operationskö
    - om s->e == t->e då g->klar
    - blockera på fas 2 barrier

4: alla trådar
    - om g->klar då break 
    - annars steg 2


Lab 2
Maila Jonas
Redovisat för David Engström

1. Data races and deadlocks 
The entire graph has a lock that protects:
- entering excess
- leaving excess
- relabeling

Then, each node has lock for when pushes are made to and from that node.

Could they be more granular?

For the node locks an order u < v is enforced to avoid deadlocks.

2. Load balancing
In this implementation, each thread will pick from the excess queue, and if the queue is empty the thread will terminate. At first I thought this would create very uneven workloads between the threads, but when examining how many nodes each thread got it was not that uneven. I tried to implement signaling with each thread having its' own work queue and a thread dedicated to handing out work. Ended up too complex..

3. Faster than sequential?
No, not at all...

4. C vs JVM
C was faster, 32 vs 55 sec.

5. Source codes

6. Improvements
Other than load balancing I was not sure what to improve. 
Ideas:
- partition the graph so that the lock contention for a single node decreases
- divide the work in rounds, do pushes and relabels seperately? 

